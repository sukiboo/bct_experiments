"""
Create a dataset consisting of healthcare messages for behavioral change.
Messages are generated by gpt-3.5-turbo-0613 model from the templatized prompt.

BCT labels/definitions/examples are taken from the BCT Taxonomy v1 available at
https://digitalwellbeing.org/wp-content/uploads/2016/11/BCTTv1_PDF_version.pdf

Processed table with corrected grammar and extra info is available at
https://docs.google.com/spreadsheets/d/1a4Ntiwa1DLkpfAGDDrKvyyB4QA4xkKhQpD9kKx-DRck
"""

import os
import re
import openai
import argparse
import pandas as pd
from retry.api import retry_call

openai.api_key = os.environ['OPENAI_API_KEY']


def generate_response(system_prompt,
                      user_prompt,
                      model='gpt-3.5-turbo-0613',
                      temperature=0,
                      **kwargs):
    """Submit user prompt to GPT model and return the response."""
    messages = [{'role': 'system', 'content': system_prompt},
                {'role': 'user', 'content': user_prompt}]
    response = openai.ChatCompletion.create(messages=messages,
                                            model=model,
                                            temperature=temperature,
                                            **kwargs)
    return response

def generate_dataset(prompt_file, num_messages):
    """Generate a dataset of messages from a given prompt."""
    # read the prompt
    system_prompt, user_prompt = read_prompt(prompt_file)
    print(f'System prompt: {system_prompt}\n\nUser prompt: {user_prompt}\n')

    # generate the dataset
    print(f'Generating dataset "{prompt_file}" with {num_messages} messages for each BCT...\n')
    os.makedirs(f'./data/{prompt_file}/', exist_ok=True)
    for ind in range(len(bcts)):

        # customize prompts for the current BCT
        bct_no = bcts.No[ind]
        sys_prompt = system_prompt.replace('{bct_label}', bcts.Label[ind])\
                                  .replace('{num_messages}', str(num_messages))
        bct_prompt = user_prompt.replace('{bct_label}', bcts.Label[ind])\
                                .replace('{bct_definition}', bcts.Definition[ind])\
                                .replace('{bct_examples}', bcts.Examples[ind])\
                                .replace('{num_messages}', str(num_messages))

        # generate messages for the current BCT
        retry_call(generate_bct_messages,
                   fargs=(bct_no, bct_prompt, sys_prompt, prompt_file),
                   tries=3)

    # merge and save the dataset
    merge_dataset(prompt_file)
    print(f'\n\nDataset "{prompt_file}" is generated and saved to "./data/{prompt_file}.csv"')

def read_prompt(prompt_file):
    """Read and parse the prompt from a given file."""
    with open(f'./prompts/{prompt_file}.txt') as prompt:
        try:
            content = prompt.read()
            # check if the prompt file contains the divider
            if '=====' in content:
                system_prompt, user_prompt = content.split('=====\n')
            # otherwise assume that the prompt consists of two lines
            else:
                system_prompt, user_prompt = content.splitlines()
            return system_prompt, user_prompt
        except:
            raise OSError(f'\nCould not parse the prompt from "./prompts/{prompt_file}.txt" file')

def generate_bct_messages(bct_no, bct_prompt, system_prompt, prompt_file):
    """Generate a set of messages for a given BCT."""
    # generate and save messages
    print(f'\n[{bct_no}] {bct_prompt}')
    response = generate_response(system_prompt, bct_prompt)

    # interrupt if the generation did not run as expected
    if response.choices[0].finish_reason != 'stop':
        raise ValueError(f'\nCould not generate messages for BCT {bct_no}:\n{response}')
    else:
        # format and save generated messages
        bct_messages = format_response(response.choices[0].message.content, num_messages)
        bct_df = pd.DataFrame(bct_messages)
        bct_df.to_csv(f'./data/{prompt_file}/{bct_no}.csv', header=False, index=False)
        print(*[f'{i+1}. {m}' for i, m in enumerate(bct_messages[:5])], sep='\n')

def format_response(content, num_messages):
    """Format the model response as a list of strings."""
    # split on new line symbols
    messages = re.split('\n+', content)
    try:
        # if more messages than required then only keep the lines that start with a number
        if len(messages) > num_messages:
            messages = [message for message in messages if message[0].isdigit()]
        # strip message numbering
        messages = [message.lstrip('0123456789. ') for message in messages]
        return messages
    except:
        raise ValueError(f'\nWrong format for the generated messages:\n{content}')

def merge_dataset(dataset_name):
    """Merge separate message files into a single dataframe."""
    dfs = []
    for bct in bcts.No.tolist():
        try:
            # read messages for the current BCT
            df = pd.read_csv(f'./data/{dataset_name}/{bct}.csv', names=['message'])
            df['bct'] = bct
            dfs.append(df)
        except FileNotFoundError:
            raise FileNotFoundError(f'\nThe file "./data/{dataset_name}/{bct}.csv" not found')
        except:
            raise OSError(f'\nCould not read the "./data/{dataset_name}/{bct}.csv" file')

    # merge all messages and save the dataframe
    df = pd.concat(dfs)
    df.reset_index(drop=True, inplace=True)
    df.to_csv(f'./data/{dataset_name}.csv')


if __name__ == '__main__':

    # parse the configs
    parser = argparse.ArgumentParser()
    parser.add_argument('-p', '--prompt',
                        default='baseline',
                        help='name of the prompt file in "./prompts/"')
    parser.add_argument('-n', '--num',
                        default=10,
                        help='number of messages to generate for each BCT')

    # read the inputs
    args = parser.parse_args()
    prompt_file = args.prompt
    num_messages = int(args.num)

    # read the BCT taxonomy
    BCT_URL = 'https://docs.google.com/spreadsheets/d/e/2PACX-1vS1NRUf8'\
              'ZMAowUBBqq69awHkuDY1ZQIQord5rbFlhHr8dcJUaQqQImEMJnhuwKtu'\
              'ASrU_cBtO7Omj9Q/pub?gid=970379036&single=true&output=csv'
    bcts = pd.read_csv(BCT_URL, dtype=str)

    # generate the dataset
    generate_dataset(prompt_file, num_messages)

